'''This module contains functions to generate interferometric pairs for InSAR processing.
Those functions only generate interferometric pairs and do not check if the interferometric
pairs are valid. For example, if the interferometric pairs are generated by `pairs_by_period`
function, the interferometric pairs may not be valid if the temporal baseline of the interferometric
pairs are too large. The users should check the temporal baseline of the interferometric pairs  
and remove the invalid interferometric pairs.
'''

from pathlib import Path
import pandas as pd
import numpy as np
from typing import List, Union, Tuple


def _day_of_pair(date_start, date_end, date_format):
    date_start = pd.to_datetime(date_start, format=date_format)
    date_end = pd.to_datetime(date_end, format=date_format)
    day = (date_end - date_start).days
    return day


def pairs_by_interval(
    dates_str: str,
    date_format: str = '%Y%m%d',
    max_interval: str = 2,
    max_day: str = 180
) -> List[Tuple[str, str]]:
    '''generate interferometric pairs by SAR acquisition interval. SAR acquisition interval is
    defined as the number of SAR acquisitions between two SAR acquisitions. For example, if the
    SAR acquisition interval is 2, then the interferometric pairs will be generated between
    SAR acquisitions with interval of 1 and 2. This will be useful to generate interferometric
    pairs with different temporal baselines.

    Parameters:
    -----------
    dates_str: str 
        date strings for all SAR acquisitions
    date_format : str
        format of dates string, which is used to convert string to datetime object. 
        Default is '%Y%m%d'. More information can be found at:
        https://docs.python.org/3.11/library/datetime.html#strftime-strptime-behavior
    max_interval: int
        max interval between two SAR acquisitions for interferometric pair.
        interval is defined as the number of SAR acquisitions between two SAR acquisitions.
    max_day:int
        max day between two SAR acquisitions for interferometric pair

    Returns:
    --------
    pair_list: a list containing interferometric pairs with each pair as a list of two dates
    '''
    num = len(dates_str)

    pair_list = []
    for i, date in enumerate(dates_str):
        n_interval = 1
        while n_interval <= max_interval:
            if i + n_interval < num:
                if _day_of_pair(date, dates_str[i + n_interval], date_format) < max_day:
                    pair = (date, dates_str[i + n_interval])
                    pair_list.append(pair)
                    n_interval += 1
                else:
                    break
            else:
                break

    return pair_list


def pairs_by_period(
    dates_str,
    date_format: str = '%Y%m%d',
    period_start: str = '1201',
    period_end: str = '0331',
    n_per_period: str = 3,
    n_primary_period: str = 2
) -> List[Tuple[str, str]]:
    '''generate interferometric pairs between periods for all years. period is defined by month 
    and day for each year. For example, period_start='1201', period_end='0331' means the period
    is from Dec 1 to Mar 31 for each year in the time series. This function will randomly select
    n_per_period dates in each period and generate interferometric pairs between those dates. This
    will be useful to mitigate the temporal cumulative bias.

    Parameters:
    -----------
    dates_str: str 
        date string with format of '%Y%m%d'
    date_format : str
        format of dates string, which is used to convert string to datetime object. 
        Default is '%Y%m%d'. More information can be found at:
        https://docs.python.org/3.11/library/datetime.html#strftime-strptime-behavior
    period_start, period_end:  str
        start and end date for the period which expressed as month and day with format '%m%d'
    n_per_period: int
        how many dates will be used for each period. Those dates will be selected randomly 
        in each period. Default is 3
    n_primary_period: int
        how many periods used as primary date of ifg. Default is 2. For example, if n_primary_period=2,
        then the interferometric pairs will be generated between the first two periods and the rest
        periods. 

    Returns:
    --------
    pair_list: a list containing interferometric pairs with each pair as a tuple of two dates
    '''
    dates = pd.to_datetime(dates_str, format=date_format)
    years = sorted(set(dates.year))
    df_dates = pd.Series(dates.strftime(date_format), index=dates)

    # check if period_start and period_end are in the same year. If not, the period_end should be
    # in the next year
    same_year = False
    if int(period_start) < int(period_end):
        same_year = True

    # randomly select n_per_period dates in each period/year
    date_years = []
    for year in years:
        start = pd.to_datetime(f'{year}{period_start}', format='%Y%m%d')
        if same_year:
            end = pd.to_datetime(f'{year}{period_end}', format='%Y%m%d')
        else:
            end = pd.to_datetime(f'{year+1}{period_end}', format='%Y%m%d')

        dt_year = df_dates[start:end]
        if len(dt_year) > 0:
            np.random.shuffle(dt_year)
            date_years.append(dt_year[:n_per_period].to_list())

    # generate interferometric pairs between primary period and the rest periods
    pair_list = []
    for i, date_year in enumerate(date_years):
        # only generate pairs for n_primary_period
        if i+1 > n_primary_period:
            break
        for date_primary in date_year:
            # all rest periods
            for date_year1 in date_years[i+1:]:
                for date_secondary in date_year1:
                    pair = (date_primary, date_secondary)
                    pair_list.append(pair)

    return pair_list


def pairs_between_summer_winter(
    dates_str: str,
    date_format: str = '%Y%m%d',
    summer_start: str = '0801',
    summer_end: str = '1001',
    winter_start: str = '1201',
    winter_end: str = '0331'
) -> List[Tuple[str, str]]:
    '''generate interferometric pairs between summer and winter in each yea. summer and winter
    are defined by month and day for each year. For example, summer_start='0801', summer_end='1001'
    means the summer is from Aug 1 to Oct 1 for each year in the time series. This will be useful
    to add pairs for whole thawing and freezing process.

    Parameters:
    -----------
    dates_str: str 
        date string with format of '%Y%m%d'
    date_format : str
        format of dates string, which is used to convert string to datetime object. 
        Default is '%Y%m%d'. More information can be found at:
        https://docs.python.org/3.11/library/datetime.html#strftime-strptime-behavior
    summer_start, summer_end:  str
        start and end date for the summer which expressed as month and day with format '%m%d'
    winter_start, winter_end:  str
        start and end date for the winter which expressed as month and day with format '%m%d'

    Returns:
    --------
    pair_list: a list containing interferometric pairs with each pair as a tuple of two dates
    '''
    dates = pd.to_datetime(dates_str, format=date_format)
    years = sorted(set(dates.year))
    df_dates = pd.Series(dates.strftime(date_format), index=dates)

    pair_list = []
    for year in years:
        s_start = pd.to_datetime(f'{year}{summer_start}', format='%Y%m%d')
        s_end = pd.to_datetime(f'{year}{summer_end}', format='%Y%m%d')

        if int(winter_start) > int(summer_end):
            w_start1 = pd.to_datetime(
                f'{year-1}{winter_start}', format='%Y%m%d')
            w_start2 = pd.to_datetime(f'{year}{winter_start}', format='%Y%m%d')
            if int(winter_end) > int(summer_end):
                w_end1 = pd.to_datetime(
                    f'{year-1}{winter_end}', format='%Y%m%d')
                w_end2 = pd.to_datetime(f'{year}{winter_end}', format='%Y%m%d')
            else:
                w_end1 = pd.to_datetime(f'{year}{winter_end}', format='%Y%m%d')
                w_end2 = pd.to_datetime(
                    f'{year+1}{winter_end}', format='%Y%m%d')
        else:
            w_start1 = pd.to_datetime(f'{year}{winter_start}', format='%Y%m%d')
            w_start2 = pd.to_datetime(
                f'{year+1}{winter_start}', format='%Y%m%d')

            w_end1 = pd.to_datetime(f'{year}{winter_end}', format='%Y%m%d')
            w_end2 = pd.to_datetime(f'{year+1}{winter_end}', format='%Y%m%d')

        dt_winter1 = df_dates[w_start1:w_end1].to_list()
        dt_summer = df_dates[s_start:s_end].to_list()
        dt_winter2 = df_dates[w_start2:w_end2].to_list()

        # thawing process
        if len(dt_winter1) > 0 and len(dt_summer) > 0:
            for dt_w1 in dt_winter1:
                for dt_s in dt_summer:
                    pair = (dt_w1, dt_s)
                    pair_list.append(pair)
        # freezing process
        if len(dt_winter2) > 0 and len(dt_summer) > 0:
            for dt_w2 in dt_winter2:
                for dt_s in dt_summer:
                    pair = (dt_s, dt_w2)
                    pair_list.append(pair)

    return pair_list
